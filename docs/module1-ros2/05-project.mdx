---
sidebar_position: 5
---

# Module 1 Project: Developing a Complete ROS2 Humanoid Robot Controller

## Project Overview

In this capstone project for Module 1, you'll develop a complete ROS2 package to control a simulated humanoid robot. This project integrates all the concepts learned in previous chapters: nodes, topics, services, actions, rclpy, and URDF. By the end of this project, you'll have a functional humanoid robot controller with walking capabilities, basic manipulation, and sensor integration.

## Project Requirements

### Core Functionality
1. Control a 22-DOF humanoid robot model in simulation
2. Implement basic walking gaits using ROS2 control
3. Create high-level action servers for walking and manipulation
4. Integrate sensor feedback for balance and navigation
5. Develop a state machine to manage different robot behaviors

### Technical Requirements
- Use ROS2 Humble Hawksbill
- Python-based implementation using rclpy
- URDF model with accurate physical properties
- Gazebo simulation integration
- ROS2 control for joint actuation

## Project Structure

Let's set up the package structure first:

```
humanoid_robot_controller/
├── CMakeLists.txt
├── package.xml
├── setup.py
├── setup.cfg
├── test/
│   └── test_copyright.py
├── launch/
│   ├── robot_simulation.launch.py
│   └── robot_control.launch.py
├── config/
│   ├── controllers.yaml
│   ├── joint_limits.yaml
│   └── walking_params.yaml
├── urdf/
│   ├── humanoid.urdf.xacro
│   └── materials.xacro
├── src/
│   ├── humanoid_controller/
│   │   ├── __init__.py
│   │   ├── robot_state_machine.py
│   │   ├── walking_controller.py
│   │   ├── manipulation_controller.py
│   │   └── sensor_processor.py
│   └── main_nodes/
│       ├── __init__.py
│       ├── robot_controller_node.py
│       ├── walking_action_server.py
│       └── manipulation_action_server.py
└── scripts/
    └── robot_teleop.py
```

## Step 1: Package Setup

### package.xml
```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>humanoid_robot_controller</name>
  <version>0.0.1</version>
  <description>Complete ROS2 controller for humanoid robots</description>
  <maintainer email="robotics@example.com">ROS Developer</maintainer>
  <license>Apache-2.0</license>

  <depend>rclpy</depend>
  <depend>std_msgs</depend>
  <depend>sensor_msgs</depend>
  <depend>geometry_msgs</depend>
  <depend>nav_msgs</depend>
  <depend>control_msgs</depend>
  <depend>action_msgs</depend>
  <depend>builtin_interfaces</depend>
  
  <exec_depend>joint_state_publisher</exec_depend>
  <exec_depend>robot_state_publisher</exec_depend>
  <exec_depend>xacro</exec_depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
```

### setup.py
```python
from setuptools import find_packages, setup
import os
from glob import glob

package_name = 'humanoid_robot_controller'

setup(
    name=package_name,
    version='0.0.1',
    packages=find_packages(exclude=['test']),
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        # Include launch files
        (os.path.join('share', package_name, 'launch'), glob('launch/*.launch.py')),
        # Include config files
        (os.path.join('share', package_name, 'config'), glob('config/*.yaml')),
        # Include URDF files
        (os.path.join('share', package_name, 'urdf'), glob('urdf/*.xacro')),
        (os.path.join('share', package_name, 'urdf'), glob('urdf/*.dae')),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='ROS Developer',
    maintainer_email='robotics@example.com',
    description='Complete ROS2 controller for humanoid robots',
    license='Apache-2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'robot_controller_node = humanoid_robot_controller.main_nodes.robot_controller_node:main',
            'walking_action_server = humanoid_robot_controller.main_nodes.walking_action_server:main',
            'manipulation_action_server = humanoid_robot_controller.main_nodes.manipulation_action_server:main',
            'robot_teleop = humanoid_robot_controller.scripts.robot_teleop:main',
        ],
    },
)
```

## Step 2: URDF Model

Let's create a simplified but complete humanoid URDF model:

### urdf/humanoid.urdf.xacro
```xml
<?xml version="1.0"?>
<robot name="humanoid_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">
  
  <!-- Constants -->
  <xacro:property name="M_PI" value="3.1415926535897931"/>
  <xacro:property name="torso_mass" value="5.0"/>
  <xacro:property name="limb_mass" value="2.0"/>
  <xacro:property name="head_mass" value="1.0"/>
  <xacro:property name="foot_mass" value="0.8"/>
  <xacro:property name="hand_mass" value="0.5"/>

  <!-- Materials -->
  <material name="black">
    <color rgba="0.0 0.0 0.0 1.0"/>
  </material>
  <material name="blue">
    <color rgba="0.0 0.0 0.8 1.0"/>
  </material>
  <material name="green">
    <color rgba="0.0 0.8 0.0 1.0"/>
  </material>
  <material name="grey">
    <color rgba="0.5 0.5 0.5 1.0"/>
  </material>
  <material name="orange">
    <color rgba="1.0 0.423529411765 0.0392156862745 1.0"/>
  </material>
  <material name="brown">
    <color rgba="0.870588235294 0.811764705882 0.764705882353 1.0"/>
  </material>
  <material name="red">
    <color rgba="0.8 0.0 0.0 1.0"/>
  </material>
  <material name="white">
    <color rgba="1.0 1.0 1.0 1.0"/>
  </material>

  <!-- Base link -->
  <link name="base_link">
    <inertial>
      <mass value="0.001"/>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <inertia ixx="0.0001" ixy="0" ixz="0" iyy="0.0001" iyz="0" izz="0.0001"/>
    </inertial>
  </link>

  <!-- Torso -->
  <link name="torso">
    <inertial>
      <mass value="${torso_mass}"/>
      <origin xyz="0 0 0.15" rpy="0 0 0"/>
      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.1"/>
    </inertial>
    
    <visual>
      <origin xyz="0 0 0.15" rpy="0 0 0"/>
      <geometry>
        <box size="0.2 0.15 0.3"/>
      </geometry>
      <material name="grey"/>
    </visual>
    
    <collision>
      <origin xyz="0 0 0.15" rpy="0 0 0"/>
      <geometry>
        <box size="0.2 0.15 0.3"/>
      </geometry>
    </collision>
  </link>

  <joint name="base_to_torso" type="fixed">
    <parent link="base_link"/>
    <child link="torso"/>
    <origin xyz="0 0 0" rpy="0 0 0"/>
  </joint>

  <!-- Head -->
  <link name="head">
    <inertial>
      <mass value="${head_mass}"/>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>
    </inertial>
    
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <sphere radius="0.1"/>
      </geometry>
      <material name="white"/>
    </visual>
    
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <sphere radius="0.1"/>
      </geometry>
    </collision>
  </link>

  <joint name="neck_joint" type="revolute">
    <parent link="torso"/>
    <child link="head"/>
    <origin xyz="0 0 0.3" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
    <limit lower="${-M_PI/3}" upper="${M_PI/3}" effort="10" velocity="${M_PI/2}"/>
    <dynamics damping="0.5" friction="0.1"/>
  </joint>

  <!-- Right Arm -->
  <xacro:macro name="arm_chain" params="side reflect prefix">
    <!-- Shoulder -->
    <joint name="${side}_shoulder_yaw_joint" type="revolute">
      <parent link="torso"/>
      <child link="${side}_shoulder"/>
      <origin xyz="0 ${reflect * 0.1} 0.25" rpy="0 0 0"/>
      <axis xyz="0 0 1"/>
      <limit lower="${-M_PI/4}" upper="${M_PI/4}" effort="30" velocity="${M_PI}"/>
      <dynamics damping="0.5" friction="0.1"/>
    </joint>

    <link name="${side}_shoulder">
      <inertial>
        <mass value="1.0"/>
        <origin xyz="0 ${reflect * 0.05} 0" rpy="0 0 0"/>
        <inertia ixx="0.005" ixy="0" ixz="0" iyy="0.005" iyz="0" izz="0.001"/>
      </inertial>
      
      <visual>
        <origin xyz="0 ${reflect * 0.05} 0" rpy="0 0 0"/>
        <geometry>
          <cylinder radius="0.04" length="0.1"/>
        </geometry>
        <material name="grey"/>
      </visual>
      
      <collision>
        <origin xyz="0 ${reflect * 0.05} 0" rpy="0 0 0"/>
        <geometry>
          <cylinder radius="0.04" length="0.1"/>
        </geometry>
      </collision>
    </link>

    <joint name="${side}_shoulder_pitch_joint" type="revolute">
      <parent link="${side}_shoulder"/>
      <child link="${side}_upper_arm"/>
      <origin xyz="0 ${reflect * 0.1} 0" rpy="0 0 0"/>
      <axis xyz="1 0 0"/>
      <limit lower="${-M_PI/2}" upper="${M_PI/2}" effort="30" velocity="${M_PI}"/>
      <dynamics damping="0.5" friction="0.1"/>
    </joint>

    <link name="${side}_upper_arm">
      <inertial>
        <mass value="1.0"/>
        <origin xyz="0 0 -0.1" rpy="0 0 0"/>
        <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.002"/>
      </inertial>
      
      <visual>
        <origin xyz="0 0 -0.1" rpy="0 0 0"/>
        <geometry>
          <cylinder radius="0.04" length="0.2"/>
        </geometry>
        <material name="grey"/>
      </visual>
      
      <collision>
        <origin xyz="0 0 -0.1" rpy="0 0 0"/>
        <geometry>
          <cylinder radius="0.04" length="0.2"/>
        </geometry>
      </collision>
    </link>

    <joint name="${side}_elbow_joint" type="revolute">
      <parent link="${side}_upper_arm"/>
      <child link="${side}_forearm"/>
      <origin xyz="0 0 -0.2" rpy="0 0 0"/>
      <axis xyz="1 0 0"/>
      <limit lower="${-M_PI/2}" upper="${M_PI/2}" effort="20" velocity="${M_PI}"/>
      <dynamics damping="0.3" friction="0.1"/>
    </joint>

    <link name="${side}_forearm">
      <inertial>
        <mass value="0.5"/>
        <origin xyz="0 0 -0.07" rpy="0 0 0"/>
        <inertia ixx="0.005" ixy="0" ixz="0" iyy="0.005" iyz="0" izz="0.001"/>
      </inertial>
      
      <visual>
        <origin xyz="0 0 -0.07" rpy="0 0 0"/>
        <geometry>
          <cylinder radius="0.03" length="0.14"/>
        </geometry>
        <material name="grey"/>
      </visual>
      
      <collision>
        <origin xyz="0 0 -0.07" rpy="0 0 0"/>
        <geometry>
          <cylinder radius="0.03" length="0.14"/>
        </geometry>
      </collision>
    </link>

    <joint name="${side}_wrist_joint" type="revolute">
      <parent link="${side}_forearm"/>
      <child link="${side}_hand"/>
      <origin xyz="0 0 -0.14" rpy="0 0 0"/>
      <axis xyz="0 1 0"/>
      <limit lower="${-M_PI/3}" upper="${M_PI/3}" effort="10" velocity="${M_PI}"/>
      <dynamics damping="0.2" friction="0.05"/>
    </joint>

    <link name="${side}_hand">
      <inertial>
        <mass value="${hand_mass}"/>
        <origin xyz="0.03 0 0" rpy="0 0 0"/>
        <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>
      </inertial>
      
      <visual>
        <origin xyz="0.03 0 0" rpy="0 0 0"/>
        <geometry>
          <box size="0.08 0.06 0.05"/>
        </geometry>
        <material name="grey"/>
      </visual>
      
      <collision>
        <origin xyz="0.03 0 0" rpy="0 0 0"/>
        <geometry>
          <box size="0.08 0.06 0.05"/>
        </geometry>
      </collision>
    </link>
  </xacro:macro>

  <xacro:arm_chain side="right" reflect="-1" prefix="r"/>
  <xacro:arm_chain side="left" reflect="1" prefix="l"/>

  <!-- Right Leg -->
  <xacro:macro name="leg_chain" params="side reflect">
    <!-- Hip -->
    <joint name="${side}_hip_yaw_joint" type="revolute">
      <parent link="torso"/>
      <child link="${side}_hip"/>
      <origin xyz="0 ${reflect * 0.075} -0.1" rpy="0 0 0"/>
      <axis xyz="0 0 1"/>
      <limit lower="${-M_PI/6}" upper="${M_PI/6}" effort="50" velocity="${M_PI}"/>
      <dynamics damping="1.0" friction="0.2"/>
    </joint>

    <link name="${side}_hip">
      <inertial>
        <mass value="1.0"/>
        <origin xyz="0 0 -0.05" rpy="0 0 0"/>
        <inertia ixx="0.005" ixy="0" ixz="0" iyy="0.005" iyz="0" izz="0.002"/>
      </inertial>
      
      <visual>
        <origin xyz="0 0 -0.05" rpy="0 0 0"/>
        <geometry>
          <cylinder radius="0.05" length="0.1"/>
        </geometry>
        <material name="grey"/>
      </visual>
      
      <collision>
        <origin xyz="0 0 -0.05" rpy="0 0 0"/>
        <geometry>
          <cylinder radius="0.05" length="0.1"/>
        </geometry>
      </collision>
    </link>

    <joint name="${side}_hip_roll_joint" type="revolute">
      <parent link="${side}_hip"/>
      <child link="${side}_thigh"/>
      <origin xyz="0 0 -0.1" rpy="0 0 0"/>
      <axis xyz="1 0 0"/>
      <limit lower="${-M_PI/3}" upper="${M_PI/3}" effort="50" velocity="${M_PI}"/>
      <dynamics damping="1.0" friction="0.2"/>
    </joint>

    <link name="${side}_thigh">
      <inertial>
        <mass value="${limb_mass}"/>
        <origin xyz="0 0 -0.15" rpy="0 0 0"/>
        <inertia ixx="0.04" ixy="0" ixz="0" iyy="0.04" iyz="0" izz="0.01"/>
      </inertial>
      
      <visual>
        <origin xyz="0 0 -0.15" rpy="0 0 0"/>
        <geometry>
          <cylinder radius="0.05" length="0.3"/>
        </geometry>
        <material name="grey"/>
      </visual>
      
      <collision>
        <origin xyz="0 0 -0.15" rpy="0 0 0"/>
        <geometry>
          <cylinder radius="0.05" length="0.3"/>
        </geometry>
      </collision>
    </link>

    <joint name="${side}_hip_pitch_joint" type="revolute">
      <parent link="${side}_thigh"/>
      <child link="${side}_shin"/>
      <origin xyz="0 0 -0.3" rpy="0 0 0"/>
      <axis xyz="1 0 0"/>
      <limit lower="0" upper="${M_PI/2}" effort="50" velocity="${M_PI}"/>
      <dynamics damping="1.0" friction="0.2"/>
    </joint>

    <link name="${side}_shin">
      <inertial>
        <mass value="${limb_mass}"/>
        <origin xyz="0 0 -0.15" rpy="0 0 0"/>
        <inertia ixx="0.04" ixy="0" ixz="0" iyy="0.04" iyz="0" izz="0.01"/>
      </inertial>
      
      <visual>
        <origin xyz="0 0 -0.15" rpy="0 0 0"/>
        <geometry>
          <cylinder radius="0.05" length="0.3"/>
        </geometry>
        <material name="grey"/>
      </visual>
      
      <collision>
        <origin xyz="0 0 -0.15" rpy="0 0 0"/>
        <geometry>
          <cylinder radius="0.05" length="0.3"/>
        </geometry>
      </collision>
    </link>

    <joint name="${side}_knee_joint" type="revolute">
      <parent link="${side}_shin"/>
      <child link="${side}_ankle"/>
      <origin xyz="0 0 -0.3" rpy="0 0 0"/>
      <axis xyz="1 0 0"/>
      <limit lower="${-M_PI/2}" upper="0" effort="50" velocity="${M_PI}"/>
      <dynamics damping="1.0" friction="0.2"/>
    </joint>

    <link name="${side}_ankle">
      <inertial>
        <mass value="0.5"/>
        <origin xyz="0 0 -0.05" rpy="0 0 0"/>
        <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.002"/>
      </inertial>
      
      <visual>
        <origin xyz="0 0 -0.05" rpy="0 0 0"/>
        <geometry>
          <cylinder radius="0.04" length="0.1"/>
        </geometry>
        <material name="grey"/>
      </visual>
      
      <collision>
        <origin xyz="0 0 -0.05" rpy="0 0 0"/>
        <geometry>
          <cylinder radius="0.04" length="0.1"/>
        </geometry>
      </collision>
    </link>

    <joint name="${side}_ankle_pitch_joint" type="revolute">
      <parent link="${side}_ankle"/>
      <child link="${side}_foot"/>
      <origin xyz="0 0 -0.1" rpy="0 0 0"/>
      <axis xyz="1 0 0"/>
      <limit lower="${-M_PI/4}" upper="${M_PI/4}" effort="30" velocity="${M_PI}"/>
      <dynamics damping="0.5" friction="0.1"/>
    </joint>

    <!-- Foot -->
    <link name="${side}_foot">
      <inertial>
        <mass value="${foot_mass}"/>
        <origin xyz="0.05 0 -0.02" rpy="0 0 0"/>
        <inertia ixx="0.005" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>
      </inertial>
      
      <visual>
        <origin xyz="0.05 0 -0.02" rpy="0 0 0"/>
        <geometry>
          <box size="0.15 0.1 0.04"/>
        </geometry>
        <material name="black"/>
      </visual>
      
      <collision>
        <origin xyz="0.05 0 -0.02" rpy="0 0 0"/>
        <geometry>
          <box size="0.15 0.1 0.04"/>
        </geometry>
      </collision>
    </link>
  </xacro:macro>

  <xacro:leg_chain side="right" reflect="-1"/>
  <xacro:leg_chain side="left" reflect="1"/>

  <!-- ROS Control interface -->
  <ros2_control name="GazeboSystem" type="system">
    <hardware>
      <plugin>gazebo_ros2_control/GazeboSystem</plugin>
    </hardware>
    
    <!-- Joints -->
    <joint name="neck_joint">
      <command_interface name="position">
        <param name="min">-1.047</param>
        <param name="max">1.047</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
    </joint>
    
    <joint name="right_hip_yaw_joint">
      <command_interface name="position">
        <param name="min">-0.524</param>
        <param name="max">0.524</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <joint name="right_hip_roll_joint">
      <command_interface name="position">
        <param name="min">-1.047</param>
        <param name="max">1.047</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <joint name="right_hip_pitch_joint">
      <command_interface name="position">
        <param name="min">0.0</param>
        <param name="max">1.571</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <joint name="right_knee_joint">
      <command_interface name="position">
        <param name="min">-1.571</param>
        <param name="max">0.0</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <joint name="right_ankle_pitch_joint">
      <command_interface name="position">
        <param name="min">-0.785</param>
        <param name="max">0.785</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <!-- More joints for other limbs -->
    <!-- Left leg joints -->
    <joint name="left_hip_yaw_joint">
      <command_interface name="position">
        <param name="min">-0.524</param>
        <param name="max">0.524</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <joint name="left_hip_roll_joint">
      <command_interface name="position">
        <param name="min">-1.047</param>
        <param name="max">1.047</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <joint name="left_hip_pitch_joint">
      <command_interface name="position">
        <param name="min">0.0</param>
        <param name="max">1.571</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <joint name="left_knee_joint">
      <command_interface name="position">
        <param name="min">-1.571</param>
        <param name="max">0.0</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <joint name="left_ankle_pitch_joint">
      <command_interface name="position">
        <param name="min">-0.785</param>
        <param name="max">0.785</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <!-- Right arm joints -->
    <joint name="right_shoulder_yaw_joint">
      <command_interface name="position">
        <param name="min">-0.785</param>
        <param name="max">0.785</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <joint name="right_shoulder_pitch_joint">
      <command_interface name="position">
        <param name="min">-1.571</param>
        <param name="max">1.571</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <joint name="right_elbow_joint">
      <command_interface name="position">
        <param name="min">-1.571</param>
        <param name="max">1.571</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <joint name="right_wrist_joint">
      <command_interface name="position">
        <param name="min">-1.047</param>
        <param name="max">1.047</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <!-- Left arm joints -->
    <joint name="left_shoulder_yaw_joint">
      <command_interface name="position">
        <param name="min">-0.785</param>
        <param name="max">0.785</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <joint name="left_shoulder_pitch_joint">
      <command_interface name="position">
        <param name="min">-1.571</param>
        <param name="max">1.571</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <joint name="left_elbow_joint">
      <command_interface name="position">
        <param name="min">-1.571</param>
        <param name="max">1.571</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
    <joint name="left_wrist_joint">
      <command_interface name="position">
        <param name="min">-1.047</param>
        <param name="max">1.047</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
  </ros2_control>

  <!-- Gazebo plugins -->
  <gazebo>
    <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">
      <parameters>$(find humanoid_robot_controller)/config/controllers.yaml</parameters>
    </plugin>
  </gazebo>

</robot>
```

## Step 3: Control Configuration

### config/controllers.yaml
```yaml
controller_manager:
  ros__parameters:
    update_rate: 100  # Hz

    joint_state_broadcaster:
      type: joint_state_broadcaster/JointStateBroadcaster

    humanoid_controller:
      type: position_controllers/JointGroupPositionController

    humanoid_imu_broadcaster:
      type: imu_sensor_broadcaster/IMUSensorBroadcaster

humanoid_controller:
  ros__parameters:
    joints:
      - neck_joint
      - right_hip_yaw_joint
      - right_hip_roll_joint
      - right_hip_pitch_joint
      - right_knee_joint
      - right_ankle_pitch_joint
      - left_hip_yaw_joint
      - left_hip_roll_joint
      - left_hip_pitch_joint
      - left_knee_joint
      - left_ankle_pitch_joint
      - right_shoulder_yaw_joint
      - right_shoulder_pitch_joint
      - right_elbow_joint
      - right_wrist_joint
      - left_shoulder_yaw_joint
      - left_shoulder_pitch_joint
      - left_elbow_joint
      - left_wrist_joint

humanoid_imu_broadcaster:
  ros__parameters:
    sensor_name: imu_sensor
    topic_name: imu/data
    frame_id: torso
```

## Step 4: Robot State Machine Implementation

### src/humanoid_controller/robot_state_machine.py
```python
from enum import Enum
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from geometry_msgs.msg import Twist
from sensor_msgs.msg import JointState
from builtin_interfaces.msg import Time
import time

class RobotState(Enum):
    IDLE = 1
    INITIALIZING = 2
    WALKING = 3
    MANIPULATING = 4
    STANDING = 5
    BALANCING = 6
    EMERGENCY_STOP = 7

class RobotStateMachine(Node):
    """State machine for humanoid robot behavior"""
    
    def __init__(self):
        super().__init__('robot_state_machine')
        
        # Initialize state
        self.current_state = RobotState.INITIALIZING
        self.previous_state = None
        self.state_start_time = self.get_clock().now()
        
        # Publishers
        self.state_publisher = self.create_publisher(String, 'robot_state', 10)
        self.cmd_vel_publisher = self.create_publisher(Twist, 'cmd_vel', 10)
        
        # Subscribers
        self.joint_state_sub = self.create_subscription(
            JointState, 'joint_states', self.joint_state_callback, 10
        )
        
        # Command subscribers
        self.command_sub = self.create_subscription(
            String, 'robot_command', self.command_callback, 10
        )
        
        # Timer to update state machine
        self.state_timer = self.create_timer(0.1, self.state_machine_update)
        
        # Robot parameters
        self.joint_positions = {}
        self.joint_velocities = {}
        self.joint_efforts = {}
        
        self.get_logger().info(f'Robot state machine initialized in state: {self.current_state}')
        self.publish_state()

    def joint_state_callback(self, msg):
        """Update joint states"""
        for i, name in enumerate(msg.name):
            if i < len(msg.position):
                self.joint_positions[name] = msg.position[i]
            if i < len(msg.velocity):
                self.joint_velocities[name] = msg.velocity[i]
            if i < len(msg.effort):
                self.joint_efforts[name] = msg.effort[i]

    def command_callback(self, msg):
        """Handle incoming commands"""
        command = msg.data.lower()
        
        # State transitions based on commands
        if command == 'stand' and self.current_state in [RobotState.IDLE, RobotState.WALKING]:
            self.set_state(RobotState.STANDING)
        elif command == 'walk' and self.current_state in [RobotState.IDLE, RobotState.STANDING]:
            self.set_state(RobotState.WALKING)
        elif command == 'idle' and self.current_state in [RobotState.STANDING, RobotState.WALKING]:
            self.set_state(RobotState.IDLE)
        elif command == 'balance' and self.current_state != RobotState.BALANCING:
            self.set_state(RobotState.BALANCING)
        elif command == 'emergency_stop':
            self.set_state(RobotState.EMERGENCY_STOP)

    def set_state(self, new_state):
        """Safely transition to a new state"""
        if self.current_state != new_state:
            self.previous_state = self.current_state
            self.current_state = new_state
            self.state_start_time = self.get_clock().now()
            self.get_logger().info(f'Transitioned to state: {self.current_state}')
            self.publish_state()

    def get_state_duration(self):
        """Get duration in current state"""
        current_time = self.get_clock().now()
        return (current_time.nanoseconds - self.state_start_time.nanoseconds) / 1e9

    def state_machine_update(self):
        """Update the state machine based on current state"""
        if self.current_state == RobotState.INITIALIZING:
            self.handle_initializing_state()
        elif self.current_state == RobotState.IDLE:
            self.handle_idle_state()
        elif self.current_state == RobotState.STANDING:
            self.handle_standing_state()
        elif self.current_state == RobotState.WALKING:
            self.handle_walking_state()
        elif self.current_state == RobotState.BALANCING:
            self.handle_balancing_state()
        elif self.current_state == RobotState.EMERGENCY_STOP:
            self.handle_emergency_stop_state()

    def handle_initializing_state(self):
        """Handle the initializing state"""
        # Initialize robot to safe position
        self.go_to_safe_position()
        
        # Transition to idle after a delay
        if self.get_state_duration() > 2.0:  # Wait 2 seconds
            self.set_state(RobotState.IDLE)

    def handle_idle_state(self):
        """Handle the idle state"""
        # Publish zero velocity
        cmd = Twist()
        self.cmd_vel_publisher.publish(cmd)

    def handle_standing_state(self):
        """Handle the standing state"""
        # Maintain standing position
        self.maintain_standing_position()

    def handle_walking_state(self):
        """Handle the walking state"""
        # Walking logic would be implemented here
        pass

    def handle_balancing_state(self):
        """Handle the balancing state"""
        # Balancing logic would be implemented here
        pass

    def handle_emergency_stop_state(self):
        """Handle the emergency stop state"""
        # Stop all movement
        cmd = Twist()
        self.cmd_vel_publisher.publish(cmd)

    def go_to_safe_position(self):
        """Move robot to a safe position on startup"""
        self.get_logger().info('Moving to safe position...')
        # Implementation would move all joints to safe positions

    def maintain_standing_position(self):
        """Maintain a stable standing position"""
        # Implementation would maintain balance
        pass

    def publish_state(self):
        """Publish current state"""
        msg = String()
        msg.data = self.current_state.name.lower()
        self.state_publisher.publish(msg)

def main():
    rclpy.init()
    state_machine = RobotStateMachine()
    
    try:
        rclpy.spin(state_machine)
    except KeyboardInterrupt:
        pass
    finally:
        state_machine.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Step 5: Walking Controller Implementation

### src/humanoid_controller/walking_controller.py
```python
import numpy as np
import math
from rclpy.node import Node
from std_msgs.msg import Float64MultiArray
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Twist
from builtin_interfaces.msg import Time

class WalkingController:
    """Implements basic walking gaits for humanoid robot"""
    
    def __init__(self, node: Node):
        self.node = node
        self.get_logger = node.get_logger
        
        # Walking parameters
        self.step_height = 0.05  # m, height of foot during swing phase
        self.step_length = 0.2   # m, distance for each step
        self.step_duration = 1.0 # s, time for each step
        self.zmp_offset = 0.02   # m, ZMP offset for stability
        
        # State variables
        self.left_foot_support = True  # Which foot is in support phase
        self.step_phase = 0.0          # Current phase of step [0, 1]
        self.is_walking = False        # Whether the robot is currently walking
        
        # Walking command
        self.linear_x = 0.0
        self.angular_z = 0.0
        
        self.get_logger().info('Walking controller initialized')

    def update_walking(self, dt):
        """Update walking pattern based on time delta"""
        if not self.is_walking:
            return []
        
        # Update step phase
        self.step_phase += dt / self.step_duration
        if self.step_phase > 1.0:
            self.step_phase = 0.0
            # Switch support foot
            self.left_foot_support = not self.left_foot_support
        
        # Generate target joint positions based on walking pattern
        target_positions = self.generate_walking_pattern()
        return target_positions

    def generate_walking_pattern(self):
        """Generate walking pattern based on current phase"""
        # Calculate phase-specific foot positions
        t = self.step_phase  # Current phase (0.0 to 1.0)
        
        # Left foot trajectory (if in swing phase)
        if not self.left_foot_support and self.is_walking:
            left_foot_x = self.calculate_foot_trajectory(t, self.left_foot_support)
        else:
            left_foot_x = 0.0  # In support, no movement
            
        # Right foot trajectory (if in swing phase)
        if self.left_foot_support and self.is_walking:
            right_foot_x = self.calculate_foot_trajectory(t, not self.left_foot_support)
        else:
            right_foot_x = 0.0  # In support, no movement
            
        # Simplified walking pattern - in a real implementation, this would calculate
        # all joint angles for both legs based on inverse kinematics
        target_positions = {
            'left_hip_yaw_joint': 0.0,
            'left_hip_roll_joint': 0.0,
            'left_hip_pitch_joint': math.radians(10) + left_foot_x * 0.1,
            'left_knee_joint': math.radians(-20) - left_foot_x * 0.2,
            'left_ankle_pitch_joint': math.radians(-10) + left_foot_x * 0.1,
            'right_hip_yaw_joint': 0.0,
            'right_hip_roll_joint': 0.0,
            'right_hip_pitch_joint': math.radians(10) + right_foot_x * 0.1,
            'right_knee_joint': math.radians(-20) - right_foot_x * 0.2,
            'right_ankle_pitch_joint': math.radians(-10) + right_foot_x * 0.1,
        }
        
        return target_positions

    def calculate_foot_trajectory(self, t, is_left_foot):
        """Calculate foot trajectory during swing phase using 5th order polynomial"""
        # Adjust for left or right foot
        side_multiplier = 1.0 if is_left_foot else -1.0
        
        # 5th order polynomial coefficients for smooth trajectory
        # This creates a smooth trajectory from 0 to step_length over the step phase
        a0 = 0.0
        a1 = 0.0
        a2 = 0.0
        a3 = 10.0 * self.step_length
        a4 = -15.0 * self.step_length
        a5 = 6.0 * self.step_length
        
        # Calculate x position based on phase
        x = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 + a5*t**5
        
        # Calculate z position for step height (sinusoidal)
        z = self.step_height * math.sin(math.pi * t)
        
        return x, z

    def start_walking(self, linear_x=0.0, angular_z=0.0):
        """Start walking with specified linear and angular velocity"""
        self.linear_x = linear_x
        self.angular_z = angular_z
        self.is_walking = True
        self.step_phase = 0.0
        self.get_logger().info(f'Starting walk: linear_x={linear_x}, angular_z={angular_z}')

    def stop_walking(self):
        """Stop walking"""
        self.linear_x = 0.0
        self.angular_z = 0.0
        self.is_walking = False
        self.get_logger().info('Stopped walking')

    def calculate_inverse_kinematics(self, foot_pos, is_left_foot):
        """Calculate joint angles for desired foot position (simplified)"""
        # Simplified 2D inverse kinematics for leg
        # In a real implementation, this would be more complex
        x, z = foot_pos
        
        # Leg length
        thigh_length = 0.3
        shin_length = 0.3
        total_length = thigh_length + shin_length
        
        # Check if position is reachable
        target_distance = math.sqrt(x**2 + z**2)
        if target_distance > total_length:
            # Scale to reachable position
            scale = total_length / target_distance
            x *= scale
            z *= scale
        
        # Calculate knee angle using law of cosines
        cos_knee = (thigh_length**2 + shin_length**2 - x**2 - z**2) / (2 * thigh_length * shin_length)
        knee_angle = math.acos(max(-1, min(1, cos_knee)))
        
        # Calculate hip angles
        hip_offset = math.atan2(z, x)
        common = (x**2 + z**2 + thigh_length**2 - shin_length**2) / (2 * thigh_length * math.sqrt(x**2 + z**2))
        hip_alpha = math.acos(max(-1, min(1, common)))
        
        hip_pitch = hip_offset - hip_alpha
        knee_pitch = math.pi - knee_angle
        
        # Ankle angle to keep foot level
        ankle_pitch = -(hip_pitch + knee_pitch)
        
        # Determine which leg to return angles for
        if is_left_foot:
            return {
                'left_hip_pitch_joint': hip_pitch,
                'left_knee_joint': knee_pitch,
                'left_ankle_pitch_joint': ankle_pitch
            }
        else:
            return {
                'right_hip_pitch_joint': hip_pitch,
                'right_knee_joint': knee_pitch,
                'right_ankle_pitch_joint': ankle_pitch
            }
```

## Step 6: Main Controller Node

### src/main_nodes/robot_controller_node.py
```python
import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile
from sensor_msgs.msg import JointState
from std_msgs.msg import String, Float64MultiArray
from geometry_msgs.msg import Twist
from humanoid_robot_controller.robot_state_machine import RobotStateMachine
from humanoid_robot_controller.walking_controller import WalkingController
import time

class RobotControllerNode(Node):
    """Main robot controller that integrates all subsystems"""
    
    def __init__(self):
        super().__init__('robot_controller_node')
        
        # Initialize subsystems
        self.state_machine = RobotStateMachine()
        self.walking_controller = WalkingController(self)
        
        # Publishers
        self.joint_command_publisher = self.create_publisher(
            Float64MultiArray, 
            '/humanoid_controller/commands', 
            10
        )
        
        # Subscribers
        self.cmd_vel_sub = self.create_subscription(
            Twist, 
            'cmd_vel', 
            self.cmd_vel_callback, 
            10
        )
        
        self.joint_state_sub = self.create_subscription(
            JointState, 
            'joint_states', 
            self.joint_state_callback, 
            10
        )
        
        # Timer for control loop
        self.control_timer = self.create_timer(0.01, self.control_loop)  # 100 Hz
        
        # Joint command cache
        self.joint_names = [
            'neck_joint',
            'right_hip_yaw_joint', 'right_hip_roll_joint', 'right_hip_pitch_joint',
            'right_knee_joint', 'right_ankle_pitch_joint',
            'left_hip_yaw_joint', 'left_hip_roll_joint', 'left_hip_pitch_joint',
            'left_knee_joint', 'left_ankle_pitch_joint',
            'right_shoulder_yaw_joint', 'right_shoulder_pitch_joint', 
            'right_elbow_joint', 'right_wrist_joint',
            'left_shoulder_yaw_joint', 'left_shoulder_pitch_joint', 
            'left_elbow_joint', 'left_wrist_joint'
        ]
        
        self.current_joint_positions = {name: 0.0 for name in self.joint_names}
        self.target_joint_positions = {name: 0.0 for name in self.joint_names}
        
        self.get_logger().info('Robot controller node initialized')

    def cmd_vel_callback(self, msg):
        """Handle velocity commands"""
        linear_x = msg.linear.x
        angular_z = msg.angular.z
        
        # Update walking controller based on velocity command
        if abs(linear_x) > 0.01 or abs(angular_z) > 0.01:
            self.walking_controller.start_walking(linear_x, angular_z)
        else:
            self.walking_controller.stop_walking()

    def joint_state_callback(self, msg):
        """Update current joint positions"""
        for i, name in enumerate(msg.name):
            if name in self.current_joint_positions:
                self.current_joint_positions[name] = msg.position[i]

    def control_loop(self):
        """Main control loop running at 100Hz"""
        dt = 0.01  # 100Hz
        
        # Update walking controller if walking
        if self.walking_controller.is_walking:
            walking_targets = self.walking_controller.update_walking(dt)
            
            # Update target positions with walking pattern
            for joint, position in walking_targets.items():
                if joint in self.target_joint_positions:
                    self.target_joint_positions[joint] = position
        
        # Publish joint commands
        self.publish_joint_commands()

    def publish_joint_commands(self):
        """Publish joint position commands"""
        msg = Float64MultiArray()
        
        # Set all positions to target values
        positions = []
        for name in self.joint_names:
            positions.append(self.target_joint_positions[name])
        
        msg.data = positions
        self.joint_command_publisher.publish(msg)

def main():
    rclpy.init()
    controller_node = RobotControllerNode()
    
    try:
        rclpy.spin(controller_node)
    except KeyboardInterrupt:
        pass
    finally:
        controller_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Step 7: Launch Files

### launch/robot_simulation.launch.py
```python
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():
    # Arguments
    use_sim_time = LaunchConfiguration('use_sim_time', default='true')
    
    return LaunchDescription([
        # Launch Gazebo
        IncludeLaunchDescription(
            PythonLaunchDescriptionSource([
                PathJoinSubstitution([
                    FindPackageShare('gazebo_ros'),
                    'launch',
                    'gazebo.launch.py'
                ])
            ]),
            launch_arguments={
                'use_sim_time': use_sim_time,
            }.items()
        ),
        
        # Spawn robot in Gazebo
        Node(
            package='gazebo_ros',
            executable='spawn_entity.py',
            arguments=[
                '-topic', 'robot_description',
                '-entity', 'humanoid_robot',
                '-x', '0', '-y', '0', '-z', '1.0'  # Spawn 1m above ground
            ],
            output='screen'
        ),
        
        # Robot state publisher
        Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            output='screen',
            parameters=[
                {'use_sim_time': use_sim_time},
                {'robot_description': 
                    PathJoinSubstitution([
                        FindPackageShare('humanoid_robot_controller'),
                        'urdf',
                        'humanoid.urdf.xacro'
                    ])
                }
            ]
        )
    ])
```

### launch/robot_control.launch.py
```python
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, RegisterEventHandler
from launch.event_handlers import OnProcessStart
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():
    # Arguments
    use_sim_time = LaunchConfiguration('use_sim_time', default='true')
    
    # Robot controller node
    robot_controller = Node(
        package='humanoid_robot_controller',
        executable='robot_controller_node',
        name='robot_controller',
        parameters=[
            {'use_sim_time': use_sim_time},
        ],
        output='screen'
    )
    
    # Controller manager
    controller_manager = Node(
        package='controller_manager',
        executable='ros2_control_node',
        parameters=[
            PathJoinSubstitution([
                FindPackageShare('humanoid_robot_controller'),
                'config',
                'controllers.yaml'
            ])
        ],
        output='screen'
    )
    
    # Joint state broadcaster
    joint_state_broadcaster_spawner = Node(
        package='controller_manager',
        executable='spawner',
        arguments=['joint_state_broadcaster'],
        output='screen'
    )
    
    # Humanoid controller spawner
    humanoid_controller_spawner = Node(
        package='controller_manager',
        executable='spawner',
        arguments=['humanoid_controller'],
        output='screen'
    )
    
    # Register event handler to start controllers after controller manager starts
    delay_controllers_after_ctrl_manager = RegisterEventHandler(
        event_handler=OnProcessStart(
            target_action=controller_manager,
            on_start=[
                joint_state_broadcaster_spawner,
            ],
        )
    )
    
    delay_humanoid_controller_spawner_after_ctrl_manager = RegisterEventHandler(
        event_handler=OnProcessStart(
            target_action=joint_state_broadcaster_spawner,
            on_start=[
                humanoid_controller_spawner,
            ],
        )
    )
    
    return LaunchDescription([
        robot_controller,
        controller_manager,
        delay_controllers_after_ctrl_manager,
        delay_humanoid_controller_spawner_after_ctrl_manager
    ])
```

## Step 8: Testing the Implementation

### scripts/robot_teleop.py
```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
import sys
import termios
import tty

msg = """
Control Your Humanoid Robot!
---------------------------
Moving around:
   u    i    o
   j    k    l
   m    ,    .

q/z : increase/decrease max speeds by 10%
w/x : increase/decrease only linear speed by 10%
e/c : increase/decrease only angular speed by 10%
space key, k : force stop
anything else : stop smoothly

CTRL-C to quit
"""

moveBindings = {
    'i': (1, 0, 0, 0),
    'o': (1, 0, 0, -1),
    'j': (0, 0, 0, 1),
    'l': (0, 0, 0, -1),
    'u': (1, 0, 0, 1),
    ',': (-1, 0, 0, 0),
    '.': (-1, 0, 0, 1),
    'm': (-1, 0, 0, -1),
}

speedBindings = {
    'q': (1.1, 1.1),
    'z': (.9, .9),
    'w': (1.1, 1),
    'x': (.9, 1),
    'e': (1, 1.1),
    'c': (1, .9),
}

class TeleopNode(Node):
    def __init__(self):
        super().__init__('humanoid_teleop_keyboard')
        self.pub = self.create_publisher(Twist, 'cmd_vel', 10)
        
        self.speed = 0.5
        self.turn = 1.0
        self.x = 0.0
        self.y = 0.0
        self.z = 0.0
        self.th = 0.0
        self.status = 0

    def getKey(self):
        tty.setraw(sys.stdin.fileno())
        key = sys.stdin.read(1)
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.settings)
        return key

    def vels(self, speed, turn):
        return f"currently:\tspeed {speed}\tturn {turn}"

    def callback(self):
        twist = Twist()
        twist.linear.x = self.x * self.speed
        twist.linear.y = self.y * self.speed
        twist.linear.z = self.z * self.speed
        twist.angular.x = 0.0
        twist.angular.y = 0.0
        twist.angular.z = self.th * self.turn
        self.pub.publish(twist)

def main():
    rclpy.init()
    node = TeleopNode()
    
    node.settings = termios.tcgetattr(sys.stdin)

    node.get_logger().info(msg)
    node.get_logger().info(node.vels(node.speed, node.turn))
    
    try:
        while True:
            key = node.getKey()
            if key in moveBindings.keys():
                node.x = moveBindings[key][0]
                node.y = moveBindings[key][1]
                node.z = moveBindings[key][2]
                node.th = moveBindings[key][3]
            elif key in speedBindings.keys():
                node.speed = node.speed * speedBindings[key][0]
                node.turn = node.turn * speedBindings[key][1]

                node.get_logger().info(node.vels(node.speed, node.turn))
                if (node.status == 14):
                    node.get_logger().info(msg)
                node.status = (node.status + 1) % 15
            elif key == ' ' or key == 'k':
                node.x = 0.0
                node.y = 0.0
                node.z = 0.0
                node.th = 0.0
            else:
                node.x = 0.0
                node.y = 0.0
                node.z = 0.0
                node.th = 0.0
                if (key == '\x03'):
                    break

            node.callback()

    except Exception as e:
        node.get_logger().error(str(e))

    finally:
        twist = Twist()
        twist.linear.x = 0.0
        twist.linear.y = 0.0
        twist.linear.z = 0.0
        twist.angular.x = 0.0
        twist.angular.y = 0.0
        twist.angular.z = 0.0
        node.pub.publish(twist)

        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, node.settings)
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Running the Complete System

To run the complete humanoid robot controller:

1. Build the package:
```bash
cd ~/ros2_ws
colcon build --packages-select humanoid_robot_controller
source install/setup.bash
```

2. Launch the simulation:
```bash
ros2 launch humanoid_robot_controller robot_simulation.launch.py
```

3. In another terminal, launch the controller:
```bash
ros2 launch humanoid_robot_controller robot_control.launch.py
```

4. In a third terminal, control the robot with keyboard:
```bash
ros2 run humanoid_robot_controller robot_teleop
```

## Project Extensions

To extend this project, consider implementing:

1. **Advanced Walking Patterns**: Implement more sophisticated walking gaits
2. **Balance Control**: Add center of mass control for stability
3. **Manipulation**: Implement arm control for object interaction
4. **Perception**: Integrate camera and LIDAR for navigation
5. **Learning**: Implement reinforcement learning for gait optimization
6. **Human-Robot Interaction**: Add voice and gesture recognition

## Summary

This project demonstrates a complete ROS2-based humanoid robot controller integrating:
- URDF modeling for complex kinematic chains
- State machine for behavior management
- Walking pattern generation
- ROS2 control for joint actuation
- Simulation integration with Gazebo

The implementation provides a solid foundation for further development of humanoid robotics applications.

Use the personalization button to adjust this content based on your experience level, or use the translation button to read this in Urdu.